#include <stdio.h>
#include <string.h>
#include <sodium.h>
#define MIN(a,b) ((a)<(b)?(a):(b))

void format_ip(unsigned char *s, int len) {
	if(s[0]=='[') {
		printf("  //[ipv6]\n");
		return;
	}
	unsigned char c=s[len];
	s[len]=0;
	unsigned char *s2;
	s2=(unsigned char*)strchr((char*)s,':');
	if(s2==NULL) {
		printf("  #define UPSTREAM_HOST \"%s\"\n", s);
		printf("  #define UPSTREAM_PORT 443\n");
	} else if(s2==s) {
		printf("  // malformed IP\n");
	} else {
		s2[-1]=0;
		printf("  #define UPSTREAM_HOST \"%s\"\n", s);
		printf("  #define UPSTREAM_PORT %s\n",s2+1);
		s2[-1]=':';
	}
	s[len]=c;
}

void format_provname(unsigned char *s, int len) {
	unsigned char *s2=s;
	unsigned char c=s[len];
	s[len]=0;
	printf("  #define UPSTREAM_SRVNAME ");
	int finished=0;
	while(!finished) {
		int sublen=0;
		for(; sublen<strlen((char*)s) && s[sublen]!='.'; sublen++);
		if(sublen==strlen((char*)s)) finished=1;
		else s[sublen]=0;
		printf("\"\\%o\" \"%s\" ", sublen, s);
		if(!finished) s[sublen]='.';
		s+=sublen+1;
	}
	printf("\"\\0\"\n");
	s=s2;
	s[len]=c;
}

int main(int argc, char **argv) {
	unsigned char line_decode[2030];
	//char hexdecode[4096];
	size_t linen=2048;
	char *lineptrO=malloc(linen);
	char *lineptr;
	int pnum=0;
	printf("// Automatically generated by sdns_decode with `make public-resolvers.h', do not edit !\n\n");
	while(getline(&lineptrO, &linen, stdin)>0) {
		lineptr=memmem(lineptrO,strlen(lineptrO),"sdns://",7);
		if(lineptr==NULL) continue;
		int urilength=MIN(strlen(lineptr)-1, (strchr(lineptr,' ')!=NULL ? strchr(lineptr,' ')-lineptr : strlen(lineptr)))-7;
		lineptr+=7;
		lineptr[urilength]=0;
		printf("#ifdef UPSTREAM_P%d\n", pnum);
		printf("  //%s : \n", lineptr-7);
		size_t bin_len;
		sodium_base642bin(line_decode,2030,lineptr,urilength,NULL,&bin_len,NULL,sodium_base64_VARIANT_URLSAFE_NO_PADDING);
		if(bin_len<10) { 
			printf("  //too short\n");
			goto cont;
		}
		//sodium_bin2hex(hexdecode,4096,line_decode,bin_len);
		//printf("%s\n",hexdecode);
		if(line_decode[0]!=0x01) { 
			printf("  //non-DNSCrypt\n"); 
			goto cont;
		}
		uint64_t *props;
		props=(uint64_t*)(line_decode+1);
		*props=le64toh(*props);
		if(*props & 1UL) printf("  // DNSSec\n"); else printf("  // ! NO DNSSec\n");
		if(*props & 2UL) printf("  // No-log\n"); else printf("  // ! LOGGING\n");
		if(*props & 4UL) printf("  // No-filtering\n"); else printf("  // ! FILTERING\n");
		unsigned char *line_decodeptr;
		line_decodeptr=line_decode+9;
		if(line_decodeptr+1+line_decodeptr[0]>line_decode+bin_len) { printf("  //too short\n\n"); goto cont; }
		format_ip(line_decodeptr+1, line_decodeptr[0]);
		line_decodeptr+=1+line_decodeptr[0];
		char pk[32], hexpk[65];
		if(line_decodeptr[0]!=32) { printf("  //unknown pubkey size : %d\n\n", line_decodeptr[0]); goto cont; }
		if(line_decodeptr+33>line_decode+bin_len) { printf("  //too short\n\n"); goto cont; }
		memcpy(pk,line_decodeptr+1,32);
		line_decodeptr+=33;
		sodium_bin2hex(hexpk,65,(unsigned char *)pk,32);
		printf("  #define UPSTREAM_PUBKEY \"%s\"\n", hexpk);
		if(line_decodeptr+1+line_decodeptr[0]>line_decode+bin_len) { printf("  //too short\n\n"); goto cont; }
		format_provname(line_decodeptr+1, line_decodeptr[0]);
		cont:
		printf("#endif\n");
		pnum++;
		linen=2048;
	}
	if(lineptrO) free(lineptrO);
}
